import {
  isServer
} from "./chunk-HYYACRO7.js";
import {
  DEV,
  createEffect,
  createSignal,
  onCleanup,
  onMount,
  untrack
} from "./chunk-YBCMLH7L.js";
import "./chunk-RSJERJUL.js";

// node_modules/@solid-primitives/utils/dist/chunk/APG4HSEJ.js
var access = (v) => typeof v === "function" && !v.length ? v() : v;
function handleDiffArray(current, prev, handleAdded, handleRemoved) {
  const currLength = current.length;
  const prevLength = prev.length;
  let i = 0;
  if (!prevLength) {
    for (; i < currLength; i++)
      handleAdded(current[i]);
    return;
  }
  if (!currLength) {
    for (; i < prevLength; i++)
      handleRemoved(prev[i]);
    return;
  }
  for (; i < prevLength; i++) {
    if (prev[i] !== current[i])
      break;
  }
  let prevEl;
  let currEl;
  prev = prev.slice(i);
  current = current.slice(i);
  for (prevEl of prev) {
    if (!current.includes(prevEl))
      handleRemoved(prevEl);
  }
  for (currEl of current) {
    if (!prev.includes(currEl))
      handleAdded(currEl);
  }
}

// node_modules/@solid-primitives/intersection-observer/dist/index.js
function observe(el, instance) {
  if (DEV && el instanceof HTMLElement && el.style.display === "contents") {
    console.warn(
      `[@solid-primitives/intersection-observer] IntersectionObserver is not able to observe elements with 'display: "contents"' style:`,
      el
    );
  }
  instance.observe(el);
}
function makeIntersectionObserver(elements, onChange, options) {
  if (isServer)
    return {
      add: () => void 0,
      remove: () => void 0,
      start: () => void 0,
      reset: () => void 0,
      stop: () => void 0,
      instance: {}
    };
  const instance = new IntersectionObserver(onChange, options);
  const add = (el) => observe(el, instance);
  const remove = (el) => instance.unobserve(el);
  const start = () => elements.forEach(add);
  const reset = () => instance.takeRecords().forEach((el) => remove(el.target));
  start();
  return { add, remove, start, stop: onCleanup(() => instance.disconnect()), reset, instance };
}
function createIntersectionObserver(elements, onChange, options) {
  if (isServer)
    return;
  const io = new IntersectionObserver(onChange, options);
  onCleanup(() => io.disconnect());
  createEffect((p) => {
    const list = elements();
    handleDiffArray(
      list,
      p,
      (el) => observe(el, io),
      (el) => io.unobserve(el)
    );
    return list;
  }, []);
}
function createViewportObserver(...a) {
  if (isServer) {
    return [() => void 0, { start: () => void 0, stop: () => void 0 }];
  }
  let initial = [];
  let options = {};
  if (Array.isArray(a[0]) || a[0] instanceof Function) {
    if (a[1] instanceof Function) {
      initial = access(a[0]).map((el) => [el, a[1]]);
      options = a[2];
    } else {
      initial = access(a[0]);
      options = a[1];
    }
  } else
    options = a[0];
  const callbacks = /* @__PURE__ */ new WeakMap();
  const onChange = (entries2, instance2) => entries2.forEach((entry) => {
    var _a;
    const cb = (_a = callbacks.get(entry.target)) == null ? void 0 : _a(entry, instance2);
    cb instanceof Function && cb(entry, instance2);
  });
  const { add, remove, stop, instance } = makeIntersectionObserver([], onChange, options);
  const addEntry = (el, callback) => {
    add(el);
    callbacks.set(el, callback);
  };
  const removeEntry = (el) => {
    callbacks.delete(el);
    remove(el);
  };
  const start = () => initial.forEach(([el, cb]) => addEntry(el, cb));
  onMount(start);
  return [addEntry, { remove: removeEntry, start, stop, instance }];
}
function createVisibilityObserver(options, setter) {
  if (isServer) {
    return () => () => false;
  }
  const callbacks = /* @__PURE__ */ new WeakMap();
  const io = new IntersectionObserver((entries2, instance) => {
    var _a;
    for (const entry of entries2)
      (_a = callbacks.get(entry.target)) == null ? void 0 : _a(entry, instance);
  }, options);
  onCleanup(() => io.disconnect());
  function removeEntry(el) {
    io.unobserve(el);
    callbacks.delete(el);
  }
  function addEntry(el, callback) {
    observe(el, io);
    callbacks.set(el, callback);
  }
  const getCallback = setter ? (get, set) => {
    const setterRef = access(setter);
    return (entry) => set(setterRef(entry, { visible: untrack(get) }));
  } : (_, set) => (entry) => set(entry.isIntersecting);
  return (element) => {
    const [isVisible, setVisible] = createSignal((options == null ? void 0 : options.initialValue) ?? false);
    const callback = getCallback(isVisible, setVisible);
    let prevEl;
    if (!(element instanceof Element)) {
      createEffect(() => {
        const el = element();
        if (el === prevEl)
          return;
        if (prevEl)
          removeEntry(prevEl);
        if (el)
          addEntry(el, callback);
        prevEl = el;
      });
    } else
      addEntry(element, callback);
    onCleanup(() => prevEl && removeEntry(prevEl));
    return isVisible;
  };
}
var Occurrence = ((Occurrence2) => {
  Occurrence2["Entering"] = "Entering";
  Occurrence2["Leaving"] = "Leaving";
  Occurrence2["Inside"] = "Inside";
  Occurrence2["Outside"] = "Outside";
  return Occurrence2;
})(Occurrence || {});
function getOccurrence(isIntersecting, prevIsIntersecting) {
  if (isServer) {
    return "Outside";
  }
  return isIntersecting ? prevIsIntersecting ? "Inside" : "Entering" : prevIsIntersecting === true ? "Leaving" : "Outside";
}
function withOccurrence(setter) {
  if (isServer) {
    return () => () => false;
  }
  return () => {
    let prevIntersecting;
    const cb = access(setter);
    return (entry, ctx) => {
      const { isIntersecting } = entry;
      const occurrence = getOccurrence(isIntersecting, prevIntersecting);
      prevIntersecting = isIntersecting;
      return cb(entry, { ...ctx, occurrence });
    };
  };
}
var DirectionX = ((DirectionX2) => {
  DirectionX2["Left"] = "Left";
  DirectionX2["Right"] = "Right";
  DirectionX2["None"] = "None";
  return DirectionX2;
})(DirectionX || {});
var DirectionY = ((DirectionY2) => {
  DirectionY2["Top"] = "Top";
  DirectionY2["Bottom"] = "Bottom";
  DirectionY2["None"] = "None";
  return DirectionY2;
})(DirectionY || {});
function getDirection(rect, prevRect, intersecting) {
  if (isServer) {
    return {
      directionX: "None",
      directionY: "None"
      /* None */
    };
  }
  let directionX = "None";
  let directionY = "None";
  if (!prevRect)
    return { directionX, directionY };
  if (rect.top < prevRect.top)
    directionY = intersecting ? "Bottom" : "Top";
  else if (rect.top > prevRect.top)
    directionY = intersecting ? "Top" : "Bottom";
  if (rect.left > prevRect.left)
    directionX = intersecting ? "Left" : "Right";
  else if (rect.left < prevRect.left)
    directionX = intersecting ? "Right" : "Left";
  return { directionX, directionY };
}
function withDirection(callback) {
  if (isServer) {
    return () => () => false;
  }
  return () => {
    let prevBounds;
    const cb = access(callback);
    return (entry, ctx) => {
      const { boundingClientRect } = entry;
      const direction = getDirection(boundingClientRect, prevBounds, entry.isIntersecting);
      prevBounds = boundingClientRect;
      return cb(entry, { ...ctx, ...direction });
    };
  };
}
export {
  DirectionX,
  DirectionY,
  Occurrence,
  createIntersectionObserver,
  createViewportObserver,
  createVisibilityObserver,
  getDirection,
  getOccurrence,
  makeIntersectionObserver,
  withDirection,
  withOccurrence
};
//# sourceMappingURL=@solid-primitives_intersection-observer.js.map
