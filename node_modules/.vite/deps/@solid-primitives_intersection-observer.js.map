{
  "version": 3,
  "sources": ["../../@solid-primitives/utils/dist/chunk/APG4HSEJ.js", "../../@solid-primitives/intersection-observer/dist/index.js"],
  "sourcesContent": ["import { DEV, untrack, getOwner, onCleanup, createSignal, sharedConfig, onMount } from 'solid-js';\nimport { isServer } from 'solid-js/web';\nexport { isServer } from 'solid-js/web';\n\n// src/index.ts\nvar isClient = !isServer;\nvar isDev = isClient && !!DEV;\nvar isProd = !isDev;\nvar noop = () => void 0;\nvar trueFn = () => true;\nvar falseFn = () => false;\nvar defaultEquals = (a, b) => a === b;\nvar EQUALS_FALSE_OPTIONS = { equals: false };\nvar INTERNAL_OPTIONS = { internal: true };\nvar ofClass = (v, c) => v instanceof c || v && v.constructor === c;\nfunction isObject(value) {\n  return value !== null && (typeof value === \"object\" || typeof value === \"function\");\n}\nvar isNonNullable = (i) => i != null;\nvar filterNonNullable = (arr) => arr.filter(isNonNullable);\nvar compare = (a, b) => a < b ? -1 : a > b ? 1 : 0;\nvar arrayEquals = (a, b) => a === b || a.length === b.length && a.every((e, i) => e === b[i]);\nfunction chain(callbacks) {\n  return (...args) => {\n    for (const callback of callbacks)\n      callback && callback(...args);\n  };\n}\nfunction reverseChain(callbacks) {\n  return (...args) => {\n    for (let i = callbacks.length - 1; i >= 0; i--) {\n      const callback = callbacks[i];\n      callback && callback(...args);\n    }\n  };\n}\nvar clamp = (n, min, max) => Math.min(Math.max(n, min), max);\nvar access = (v) => typeof v === \"function\" && !v.length ? v() : v;\nvar asArray = (value) => Array.isArray(value) ? value : value ? [value] : [];\nvar accessArray = (list) => list.map((v) => access(v));\nvar withAccess = (value, fn) => {\n  const _value = access(value);\n  typeof _value != null && fn(_value);\n};\nvar asAccessor = (v) => typeof v === \"function\" ? v : () => v;\nfunction accessWith(valueOrFn, ...args) {\n  return typeof valueOrFn === \"function\" ? valueOrFn(...args) : valueOrFn;\n}\nfunction defer(deps, fn, initialValue) {\n  const isArray = Array.isArray(deps);\n  let prevInput;\n  let shouldDefer = true;\n  return (prevValue) => {\n    let input;\n    if (isArray) {\n      input = Array(deps.length);\n      for (let i = 0; i < deps.length; i++)\n        input[i] = deps[i]();\n    } else\n      input = deps();\n    if (shouldDefer) {\n      shouldDefer = false;\n      prevInput = input;\n      return initialValue;\n    }\n    const result = untrack(() => fn(input, prevInput, prevValue));\n    prevInput = input;\n    return result;\n  };\n}\nvar entries = Object.entries;\nvar keys = Object.keys;\nvar tryOnCleanup = isDev ? (fn) => getOwner() ? onCleanup(fn) : fn : onCleanup;\nvar createCallbackStack = () => {\n  let stack = [];\n  const clear = () => stack = [];\n  return {\n    push: (...callbacks) => stack.push(...callbacks),\n    execute(arg0, arg1, arg2, arg3) {\n      stack.forEach((cb) => cb(arg0, arg1, arg2, arg3));\n      clear();\n    },\n    clear\n  };\n};\nfunction createMicrotask(fn) {\n  let calls = 0;\n  let args;\n  onCleanup(() => calls = 0);\n  return (...a) => {\n    args = a, calls++;\n    queueMicrotask(() => --calls === 0 && fn(...args));\n  };\n}\nfunction createHydratableSignal(serverValue, update, options) {\n  if (isServer) {\n    return createSignal(serverValue, options);\n  }\n  if (sharedConfig.context) {\n    const [state, setState] = createSignal(serverValue, options);\n    onMount(() => setState(() => update()));\n    return [state, setState];\n  }\n  return createSignal(update(), options);\n}\nvar createHydrateSignal = createHydratableSignal;\nfunction handleDiffArray(current, prev, handleAdded, handleRemoved) {\n  const currLength = current.length;\n  const prevLength = prev.length;\n  let i = 0;\n  if (!prevLength) {\n    for (; i < currLength; i++)\n      handleAdded(current[i]);\n    return;\n  }\n  if (!currLength) {\n    for (; i < prevLength; i++)\n      handleRemoved(prev[i]);\n    return;\n  }\n  for (; i < prevLength; i++) {\n    if (prev[i] !== current[i])\n      break;\n  }\n  let prevEl;\n  let currEl;\n  prev = prev.slice(i);\n  current = current.slice(i);\n  for (prevEl of prev) {\n    if (!current.includes(prevEl))\n      handleRemoved(prevEl);\n  }\n  for (currEl of current) {\n    if (!prev.includes(currEl))\n      handleAdded(currEl);\n  }\n}\n\nexport { EQUALS_FALSE_OPTIONS, INTERNAL_OPTIONS, access, accessArray, accessWith, arrayEquals, asAccessor, asArray, chain, clamp, compare, createCallbackStack, createHydratableSignal, createHydrateSignal, createMicrotask, defaultEquals, defer, entries, falseFn, filterNonNullable, handleDiffArray, isClient, isDev, isNonNullable, isObject, isProd, keys, noop, ofClass, reverseChain, trueFn, tryOnCleanup, withAccess };\n", "import { onCleanup, createEffect, onMount, createSignal, DEV, untrack } from 'solid-js';\nimport { isServer } from 'solid-js/web';\nimport { handleDiffArray, access } from '@solid-primitives/utils';\n\n// src/index.ts\nfunction observe(el, instance) {\n  if (DEV && el instanceof HTMLElement && el.style.display === \"contents\") {\n    console.warn(\n      `[@solid-primitives/intersection-observer] IntersectionObserver is not able to observe elements with 'display: \"contents\"' style:`,\n      el\n    );\n  }\n  instance.observe(el);\n}\nfunction makeIntersectionObserver(elements, onChange, options) {\n  if (isServer)\n    return {\n      add: () => void 0,\n      remove: () => void 0,\n      start: () => void 0,\n      reset: () => void 0,\n      stop: () => void 0,\n      instance: {}\n    };\n  const instance = new IntersectionObserver(onChange, options);\n  const add = (el) => observe(el, instance);\n  const remove = (el) => instance.unobserve(el);\n  const start = () => elements.forEach(add);\n  const reset = () => instance.takeRecords().forEach((el) => remove(el.target));\n  start();\n  return { add, remove, start, stop: onCleanup(() => instance.disconnect()), reset, instance };\n}\nfunction createIntersectionObserver(elements, onChange, options) {\n  if (isServer)\n    return;\n  const io = new IntersectionObserver(onChange, options);\n  onCleanup(() => io.disconnect());\n  createEffect((p) => {\n    const list = elements();\n    handleDiffArray(\n      list,\n      p,\n      (el) => observe(el, io),\n      (el) => io.unobserve(el)\n    );\n    return list;\n  }, []);\n}\nfunction createViewportObserver(...a) {\n  if (isServer) {\n    return [() => void 0, { start: () => void 0, stop: () => void 0 }];\n  }\n  let initial = [];\n  let options = {};\n  if (Array.isArray(a[0]) || a[0] instanceof Function) {\n    if (a[1] instanceof Function) {\n      initial = access(a[0]).map((el) => [el, a[1]]);\n      options = a[2];\n    } else {\n      initial = access(a[0]);\n      options = a[1];\n    }\n  } else\n    options = a[0];\n  const callbacks = /* @__PURE__ */ new WeakMap();\n  const onChange = (entries, instance2) => entries.forEach((entry) => {\n    const cb = callbacks.get(entry.target)?.(entry, instance2);\n    cb instanceof Function && cb(entry, instance2);\n  });\n  const { add, remove, stop, instance } = makeIntersectionObserver([], onChange, options);\n  const addEntry = (el, callback) => {\n    add(el);\n    callbacks.set(el, callback);\n  };\n  const removeEntry = (el) => {\n    callbacks.delete(el);\n    remove(el);\n  };\n  const start = () => initial.forEach(([el, cb]) => addEntry(el, cb));\n  onMount(start);\n  return [addEntry, { remove: removeEntry, start, stop, instance }];\n}\nfunction createVisibilityObserver(options, setter) {\n  if (isServer) {\n    return () => () => false;\n  }\n  const callbacks = /* @__PURE__ */ new WeakMap();\n  const io = new IntersectionObserver((entries, instance) => {\n    for (const entry of entries)\n      callbacks.get(entry.target)?.(entry, instance);\n  }, options);\n  onCleanup(() => io.disconnect());\n  function removeEntry(el) {\n    io.unobserve(el);\n    callbacks.delete(el);\n  }\n  function addEntry(el, callback) {\n    observe(el, io);\n    callbacks.set(el, callback);\n  }\n  const getCallback = setter ? (get, set) => {\n    const setterRef = access(setter);\n    return (entry) => set(setterRef(entry, { visible: untrack(get) }));\n  } : (_, set) => (entry) => set(entry.isIntersecting);\n  return (element) => {\n    const [isVisible, setVisible] = createSignal(options?.initialValue ?? false);\n    const callback = getCallback(isVisible, setVisible);\n    let prevEl;\n    if (!(element instanceof Element)) {\n      createEffect(() => {\n        const el = element();\n        if (el === prevEl)\n          return;\n        if (prevEl)\n          removeEntry(prevEl);\n        if (el)\n          addEntry(el, callback);\n        prevEl = el;\n      });\n    } else\n      addEntry(element, callback);\n    onCleanup(() => prevEl && removeEntry(prevEl));\n    return isVisible;\n  };\n}\nvar Occurrence = /* @__PURE__ */ ((Occurrence2) => {\n  Occurrence2[\"Entering\"] = \"Entering\";\n  Occurrence2[\"Leaving\"] = \"Leaving\";\n  Occurrence2[\"Inside\"] = \"Inside\";\n  Occurrence2[\"Outside\"] = \"Outside\";\n  return Occurrence2;\n})(Occurrence || {});\nfunction getOccurrence(isIntersecting, prevIsIntersecting) {\n  if (isServer) {\n    return \"Outside\" /* Outside */;\n  }\n  return isIntersecting ? prevIsIntersecting ? \"Inside\" /* Inside */ : \"Entering\" /* Entering */ : prevIsIntersecting === true ? \"Leaving\" /* Leaving */ : \"Outside\" /* Outside */;\n}\nfunction withOccurrence(setter) {\n  if (isServer) {\n    return () => () => false;\n  }\n  return () => {\n    let prevIntersecting;\n    const cb = access(setter);\n    return (entry, ctx) => {\n      const { isIntersecting } = entry;\n      const occurrence = getOccurrence(isIntersecting, prevIntersecting);\n      prevIntersecting = isIntersecting;\n      return cb(entry, { ...ctx, occurrence });\n    };\n  };\n}\nvar DirectionX = /* @__PURE__ */ ((DirectionX2) => {\n  DirectionX2[\"Left\"] = \"Left\";\n  DirectionX2[\"Right\"] = \"Right\";\n  DirectionX2[\"None\"] = \"None\";\n  return DirectionX2;\n})(DirectionX || {});\nvar DirectionY = /* @__PURE__ */ ((DirectionY2) => {\n  DirectionY2[\"Top\"] = \"Top\";\n  DirectionY2[\"Bottom\"] = \"Bottom\";\n  DirectionY2[\"None\"] = \"None\";\n  return DirectionY2;\n})(DirectionY || {});\nfunction getDirection(rect, prevRect, intersecting) {\n  if (isServer) {\n    return {\n      directionX: \"None\" /* None */,\n      directionY: \"None\" /* None */\n    };\n  }\n  let directionX = \"None\" /* None */;\n  let directionY = \"None\" /* None */;\n  if (!prevRect)\n    return { directionX, directionY };\n  if (rect.top < prevRect.top)\n    directionY = intersecting ? \"Bottom\" /* Bottom */ : \"Top\" /* Top */;\n  else if (rect.top > prevRect.top)\n    directionY = intersecting ? \"Top\" /* Top */ : \"Bottom\" /* Bottom */;\n  if (rect.left > prevRect.left)\n    directionX = intersecting ? \"Left\" /* Left */ : \"Right\" /* Right */;\n  else if (rect.left < prevRect.left)\n    directionX = intersecting ? \"Right\" /* Right */ : \"Left\" /* Left */;\n  return { directionX, directionY };\n}\nfunction withDirection(callback) {\n  if (isServer) {\n    return () => () => false;\n  }\n  return () => {\n    let prevBounds;\n    const cb = access(callback);\n    return (entry, ctx) => {\n      const { boundingClientRect } = entry;\n      const direction = getDirection(boundingClientRect, prevBounds, entry.isIntersecting);\n      prevBounds = boundingClientRect;\n      return cb(entry, { ...ctx, ...direction });\n    };\n  };\n}\n\nexport { DirectionX, DirectionY, Occurrence, createIntersectionObserver, createViewportObserver, createVisibilityObserver, getDirection, getOccurrence, makeIntersectionObserver, withDirection, withOccurrence };\n"],
  "mappings": "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",
  "names": ["entries"]
}
