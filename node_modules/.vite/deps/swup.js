import "./chunk-RSJERJUL.js";

// node_modules/delegate-it/delegate.js
var ledger = /* @__PURE__ */ new WeakMap();
function editLedger(wanted, baseElement, callback, setup) {
  if (!wanted && !ledger.has(baseElement)) {
    return false;
  }
  const elementMap = ledger.get(baseElement) ?? /* @__PURE__ */ new WeakMap();
  ledger.set(baseElement, elementMap);
  const setups = elementMap.get(callback) ?? /* @__PURE__ */ new Set();
  elementMap.set(callback, setups);
  const existed = setups.has(setup);
  if (wanted) {
    setups.add(setup);
  } else {
    setups.delete(setup);
  }
  return existed && wanted;
}
function safeClosest(event, selector) {
  let target = event.target;
  if (target instanceof Text) {
    target = target.parentElement;
  }
  if (target instanceof Element && event.currentTarget instanceof Element) {
    const closest = target.closest(selector);
    if (closest && event.currentTarget.contains(closest)) {
      return closest;
    }
  }
}
function delegate(selector, type, callback, options = {}) {
  const { signal, base = document } = options;
  if (signal == null ? void 0 : signal.aborted) {
    return;
  }
  const { once, ...nativeListenerOptions } = options;
  const baseElement = base instanceof Document ? base.documentElement : base;
  const capture = Boolean(typeof options === "object" ? options.capture : options);
  const listenerFn = (event) => {
    const delegateTarget = safeClosest(event, selector);
    if (delegateTarget) {
      const delegateEvent = Object.assign(event, { delegateTarget });
      callback.call(baseElement, delegateEvent);
      if (once) {
        baseElement.removeEventListener(type, listenerFn, nativeListenerOptions);
        editLedger(false, baseElement, callback, setup);
      }
    }
  };
  const setup = JSON.stringify({ selector, type, capture });
  const isAlreadyListening = editLedger(true, baseElement, callback, setup);
  if (!isAlreadyListening) {
    baseElement.addEventListener(type, listenerFn, nativeListenerOptions);
  }
  signal == null ? void 0 : signal.addEventListener("abort", () => {
    editLedger(false, baseElement, callback, setup);
  });
}
var delegate_default = delegate;

// node_modules/swup/dist/Swup.modern.js
function e() {
  return e = Object.assign ? Object.assign.bind() : function(t) {
    for (var e2 = 1; e2 < arguments.length; e2++) {
      var n2 = arguments[e2];
      for (var i2 in n2)
        Object.prototype.hasOwnProperty.call(n2, i2) && (t[i2] = n2[i2]);
    }
    return t;
  }, e.apply(this, arguments);
}
var n = (t, e2) => String(t).toLowerCase().replace(/[\s/_.]+/g, "-").replace(/[^\w-]+/g, "").replace(/--+/g, "-").replace(/^-+|-+$/g, "") || e2 || "";
var i = ({ hash: t } = {}) => location.pathname + location.search + (t ? location.hash : "");
var s = (t, n2 = {}) => {
  const s2 = e({ url: t = t || i({ hash: true }), random: Math.random(), source: "swup" }, n2);
  history.pushState(s2, "", t);
};
var o = (t = null, n2 = {}) => {
  t = t || i({ hash: true });
  const s2 = e({}, history.state, { url: t, random: Math.random(), source: "swup" }, n2);
  history.replaceState(s2, "", t);
};
var r = (e2, n2, i2, s2) => {
  const o2 = new AbortController();
  return delegate_default(e2, n2, i2, s2), { destroy: () => o2.abort() };
};
var a = (t, e2 = document) => e2.querySelector(t);
var l = (t, e2 = document) => Array.from(e2.querySelectorAll(t));
var c = (t) => {
  requestAnimationFrame(() => {
    requestAnimationFrame(() => {
      t();
    });
  });
};
var u = (t) => window.CSS && window.CSS.escape ? CSS.escape(t) : t;
var h = (t) => 1e3 * Number(t.slice(0, -1).replace(",", "."));
var d = (t, e2) => {
  var n2, i2;
  let s2 = document.createElement("html");
  s2.innerHTML = t;
  let o2 = [];
  e2.forEach((t2) => {
    if (null == a(t2, s2))
      return console.warn(`[swup] Container ${t2} not found on page.`), null;
    l(t2).length !== l(t2, s2).length && console.warn("[swup] Mismatched number of containers found on new page."), l(t2).forEach((e3, n3) => {
      l(t2, s2)[n3].setAttribute("data-swup", String(o2.length)), o2.push(l(t2, s2)[n3].outerHTML);
    });
  });
  const r2 = (null == (n2 = a("title", s2)) ? void 0 : n2.innerText) || "", c2 = null == (i2 = a("body", s2)) ? void 0 : i2.className;
  return s2.innerHTML = "", s2 = null, { title: r2, pageClass: c2, blocks: o2, originalContent: t };
};
var p = (t, n2) => {
  const i2 = { url: window.location.pathname + window.location.search, method: "GET", data: null, headers: {} }, { url: s2, method: o2, headers: r2, data: a2 } = e({}, i2, t), l2 = new XMLHttpRequest();
  return l2.onreadystatechange = function() {
    4 === l2.readyState && n2(l2);
  }, l2.open(o2, s2, true), Object.entries(r2).forEach(([t2, e2]) => {
    l2.setRequestHeader(t2, e2);
  }), l2.send(a2), l2;
};
var g = class extends URL {
  constructor(t, e2 = document.baseURI) {
    super(t.toString(), e2);
  }
  get url() {
    return this.pathname + this.search;
  }
  static fromElement(t) {
    const e2 = t.getAttribute("href") || t.getAttribute("xlink:href");
    return new g(e2);
  }
  static fromUrl(t) {
    return new g(t);
  }
};
var m = (t, e2) => {
  let n2 = 0;
  e2.forEach((e3) => {
    null == a(e3, t) ? console.warn(`[swup] Container ${e3} not found on page.`) : l(e3).forEach((i2, s2) => {
      l(e3, t)[s2].setAttribute("data-swup", String(n2)), n2++;
    });
  });
};
var f = (t) => /^to-/.test(t) || ["is-changing", "is-rendering", "is-popstate"].includes(t);
var v = () => {
  const t = document.documentElement.className.split(" ").filter(f);
  document.documentElement.classList.remove(...t);
};
var w = class {
  constructor(t) {
    this.pages = {}, this.last = null, this.swup = void 0, this.swup = t;
  }
  getCacheUrl(t) {
    return this.swup.resolveUrl(g.fromUrl(t).url);
  }
  cacheUrl(t) {
    t.url = this.getCacheUrl(t.url), t.url in this.pages == 0 && (this.pages[t.url] = t), t.responseURL = this.getCacheUrl(t.responseURL), this.last = this.pages[t.url], this.swup.log(`Cache (${Object.keys(this.pages).length})`, this.pages);
  }
  getPage(t) {
    return t = this.getCacheUrl(t), this.pages[t];
  }
  getCurrentPage() {
    return this.getPage(i());
  }
  exists(t) {
    return (t = this.getCacheUrl(t)) in this.pages;
  }
  empty() {
    this.pages = {}, this.last = null, this.swup.log("Cache cleared");
  }
  remove(t) {
    delete this.pages[this.getCacheUrl(t)];
  }
};
var E = function({ event: t, skipTransition: e2 } = {}) {
  if (e2)
    return this.triggerEvent("transitionEnd", t), this.cleanupAnimationClasses(), [Promise.resolve()];
  c(() => {
    this.triggerEvent("animationInStart"), document.documentElement.classList.remove("is-animating");
  });
  const n2 = this.getAnimationPromises("in");
  return Promise.all(n2).then(() => {
    this.triggerEvent("animationInDone"), this.triggerEvent("transitionEnd", t), this.cleanupAnimationClasses();
  }), n2;
};
var P = (t) => {
  if (t && "#" === t.charAt(0) && (t = t.substring(1)), !t)
    return null;
  const e2 = decodeURIComponent(t);
  return document.getElementById(t) || document.getElementById(e2) || a(`a[name='${u(t)}']`) || a(`a[name='${u(e2)}']`);
};
var S = "transition";
var b = "transitionend";
var y = "animation";
var U = "animationend";
function k(t) {
  const e2 = this.options.animationSelector;
  if (false === e2)
    return [Promise.resolve()];
  const n2 = l(e2, document.body);
  if (!n2.length)
    return console.warn(`[swup] No elements found matching animationSelector \`${e2}\``), [Promise.resolve()];
  const i2 = n2.map((t2) => function(t3) {
    const { type: e3, timeout: n3, propCount: i3 } = function(t4, e4 = null) {
      const n4 = window.getComputedStyle(t4), i4 = `${S}Duration`, s2 = `${y}Delay`, o2 = `${y}Duration`, r2 = n4[`${S}Delay`].split(", "), a2 = (n4[i4] || "").split(", "), l2 = L(r2, a2), c2 = (n4[s2] || "").split(", "), u2 = (n4[o2] || "").split(", "), h2 = L(c2, u2);
      let d2 = "", p2 = 0, g2 = 0;
      return "transition" === e4 ? l2 > 0 && (d2 = "transition", p2 = l2, g2 = a2.length) : "animation" === e4 ? h2 > 0 && (d2 = "animation", p2 = h2, g2 = u2.length) : (p2 = Math.max(l2, h2), d2 = p2 > 0 ? l2 > h2 ? "transition" : "animation" : null, g2 = d2 ? "transition" === d2 ? a2.length : u2.length : 0), { type: d2, timeout: p2, propCount: g2 };
    }(t3);
    if (e3 && n3)
      return new Promise((s2) => {
        const o2 = "transition" === e3 ? b : U, r2 = performance.now();
        let a2 = 0;
        const l2 = () => {
          t3.removeEventListener(o2, c2), s2();
        }, c2 = (e4) => {
          if (e4.target === t3) {
            if (!((t4) => [b, U].includes(t4.type))(e4))
              throw new Error("Not a transition or animation event.");
            (performance.now() - r2) / 1e3 < e4.elapsedTime || ++a2 >= i3 && l2();
          }
        };
        setTimeout(() => {
          a2 < i3 && l2();
        }, n3 + 1), t3.addEventListener(o2, c2);
      });
  }(t2)).filter(Boolean);
  return i2.length ? i2 : (console.warn(`[swup] No CSS animation duration defined on elements matching \`${e2}\``), [Promise.resolve()]);
}
function L(t, e2) {
  for (; t.length < e2.length; )
    t = t.concat(t);
  return Math.max(...e2.map((e3, n2) => h(e3) + h(t[n2])));
}
void 0 === window.ontransitionend && void 0 !== window.onwebkittransitionend && (S = "WebkitTransition", b = "webkitTransitionEnd"), void 0 === window.onanimationend && void 0 !== window.onwebkitanimationend && (y = "WebkitAnimation", U = "webkitAnimationEnd");
var C = function(t) {
  const n2 = d(t.responseText, this.options.containers);
  return n2 ? e({}, n2, { responseURL: t.responseURL || window.location.href }) : (console.warn("[swup] Received page is invalid."), null);
};
function T(t) {
  const n2 = this.options.requestHeaders, { url: i2 } = t;
  return this.cache.exists(i2) ? (this.triggerEvent("pageRetrievedFromCache"), Promise.resolve(this.cache.getPage(i2))) : new Promise((s2, o2) => {
    p(e({}, t, { headers: n2 }), (t2) => {
      if (500 === t2.status)
        return this.triggerEvent("serverError"), void o2(i2);
      const n3 = this.getPageData(t2);
      if (!n3 || !n3.blocks.length)
        return void o2(i2);
      const r2 = e({}, n3, { url: i2 });
      this.cache.cacheUrl(r2), this.triggerEvent("pageLoaded"), s2(r2);
    });
  });
}
var H = function({ event: t, skipTransition: e2 } = {}) {
  const n2 = t instanceof PopStateEvent;
  if (e2)
    return this.triggerEvent("animationSkipped"), [Promise.resolve()];
  this.triggerEvent("animationOutStart"), document.documentElement.classList.add("is-changing", "is-leaving", "is-animating"), n2 && document.documentElement.classList.add("is-popstate");
  const i2 = this.getAnimationPromises("out");
  return Promise.all(i2).then(() => {
    this.triggerEvent("animationOutDone");
  }), i2;
};
function R(t) {
  const { url: e2 } = t;
  this.shouldIgnoreVisit(e2) ? window.location.href = e2 : this.performPageLoad(t);
}
function A(t) {
  const { url: e2, event: r2, customTransition: a2, history: l2 = "push" } = null != t ? t : {}, c2 = r2 instanceof PopStateEvent, u2 = this.shouldSkipTransition({ url: e2, event: r2 });
  this.triggerEvent("transitionStart", r2), this.updateTransition(i(), e2, a2), null != a2 && document.documentElement.classList.add(`to-${n(a2)}`);
  const h2 = this.leavePage({ event: r2, skipTransition: u2 }), d2 = this.fetchPage(t);
  if (!c2) {
    const t2 = e2 + (this.scrollToElement || "");
    "replace" === l2 ? o(t2) : s(t2);
  }
  this.currentPageUrl = i(), Promise.all([d2, ...h2]).then(([t2]) => {
    this.renderPage(t2, { event: r2, skipTransition: u2 });
  }).catch((t2) => {
    void 0 !== t2 && (this.options.skipPopStateHandling = () => (window.location = t2, true), history.go(-1));
  });
}
var $ = function({ blocks: t, title: e2 }) {
  return t.forEach((t2, e3) => {
    document.body.querySelector(`[data-swup="${e3}"]`).outerHTML = t2;
  }), document.title = e2, Promise.resolve();
};
function _(t, e2) {
  const n2 = this._handlers[t];
  n2 ? n2.push(e2) : console.warn(`Unsupported event ${t}.`);
}
function I(t, e2) {
  if (t && e2) {
    const n2 = this._handlers[t];
    n2.includes(e2) ? this._handlers[t] = n2.filter((t2) => t2 !== e2) : console.warn(`Handler for event '${t}' not found.`);
  } else
    t ? this._handlers[t] = [] : Object.keys(this._handlers).forEach((t2) => {
      this._handlers[t2] = [];
    });
}
function x(t, e2) {
  this._handlers[t].forEach((t2) => {
    try {
      t2(e2);
    } catch (t3) {
      console.error(t3);
    }
  });
  const n2 = new CustomEvent(`swup:${t}`, { detail: t });
  document.dispatchEvent(n2);
}
var O = function(t) {
  var e2;
  if (null == (e2 = t) ? void 0 : e2.isSwupPlugin) {
    if (t.swup = this, !t._checkRequirements || t._checkRequirements())
      return t._beforeMount && t._beforeMount(), t.mount(), this.plugins.push(t), this.plugins;
  } else
    console.error("Not a swup plugin instance", t);
};
function q(t) {
  const e2 = this.findPlugin(t);
  if (e2)
    return e2.unmount(), e2._afterUnmount && e2._afterUnmount(), this.plugins = this.plugins.filter((t2) => t2 !== e2), this.plugins;
  console.error("No such plugin", e2);
}
function D(t) {
  return this.plugins.find((e2) => e2 === t || e2.name === t);
}
var M = function(t, { event: n2, skipTransition: s2 } = {}) {
  if (document.documentElement.classList.remove("is-leaving"), !this.isSameResolvedUrl(i(), t.url))
    return;
  const { url: r2 } = g.fromUrl(t.responseURL);
  this.isSameResolvedUrl(i(), r2) || (this.cache.cacheUrl(e({}, t, { url: r2 })), this.currentPageUrl = i(), o(r2)), s2 || document.documentElement.classList.add("is-rendering"), this.triggerEvent("willReplaceContent", n2), this.replaceContent(t).then(() => {
    this.triggerEvent("contentReplaced", n2), this.triggerEvent("pageView", n2), this.options.cache || this.cache.empty(), this.enterPage({ event: n2, skipTransition: s2 }), this.scrollToElement = null;
  });
};
function N(t, e2, n2) {
  this.transition = { from: t, to: e2, custom: n2 };
}
function W({ event: t }) {
  return !(!(t instanceof PopStateEvent) || this.options.animateHistoryBrowsing);
}
var V = class {
  constructor(t = {}) {
    this.version = "3.1.0", this._handlers = { animationInDone: [], animationInStart: [], animationOutDone: [], animationOutStart: [], animationSkipped: [], clickLink: [], contentReplaced: [], disabled: [], enabled: [], openPageInNewTab: [], pageLoaded: [], pageRetrievedFromCache: [], pageView: [], popState: [], samePage: [], samePageWithHash: [], serverError: [], transitionStart: [], transitionEnd: [], willReplaceContent: [] }, this.scrollToElement = null, this.options = void 0, this.plugins = [], this.transition = {}, this.cache = void 0, this.currentPageUrl = i(), this.delegatedListeners = {}, this.boundPopStateHandler = void 0, this.loadPage = R, this.performPageLoad = A, this.leavePage = H, this.renderPage = M, this.replaceContent = $, this.enterPage = E, this.triggerEvent = x, this.delegateEvent = r, this.on = _, this.off = I, this.updateTransition = N, this.shouldSkipTransition = W, this.getAnimationPromises = k, this.getPageData = C, this.fetchPage = T, this.getAnchorElement = P, this.log = () => {
    }, this.use = O, this.unuse = q, this.findPlugin = D, this.getCurrentUrl = i, this.cleanupAnimationClasses = v, this.defaults = { animateHistoryBrowsing: false, animationSelector: '[class*="transition-"]', cache: true, containers: ["#swup"], ignoreVisit: (t2, { el: e2 } = {}) => !(null == e2 || !e2.closest("[data-no-swup]")), linkSelector: "a[href]", plugins: [], resolveUrl: (t2) => t2, requestHeaders: { "X-Requested-With": "swup", Accept: "text/html, application/xhtml+xml" }, skipPopStateHandling: (t2) => {
      var e2;
      return "swup" !== (null == (e2 = t2.state) ? void 0 : e2.source);
    } }, this.options = e({}, this.defaults, t), this.boundPopStateHandler = this.popStateHandler.bind(this), this.cache = new w(this), this.enable();
  }
  enable() {
    "undefined" != typeof Promise ? (this.delegatedListeners.click = r(this.options.linkSelector, "click", this.linkClickHandler.bind(this)), window.addEventListener("popstate", this.boundPopStateHandler), m(document.documentElement, this.options.containers), this.options.plugins.forEach((t) => this.use(t)), o(), this.triggerEvent("enabled"), document.documentElement.classList.add("swup-enabled"), this.triggerEvent("pageView")) : console.warn("Promise is not supported");
  }
  destroy() {
    this.delegatedListeners.click.destroy(), window.removeEventListener("popstate", this.boundPopStateHandler), this.cache.empty(), this.options.plugins.forEach((t) => {
      this.unuse(t);
    }), l("[data-swup]").forEach((t) => {
      t.removeAttribute("data-swup");
    }), this.off(), this.triggerEvent("disabled"), document.documentElement.classList.remove("swup-enabled");
  }
  shouldIgnoreVisit(t, { el: e2, event: n2 } = {}) {
    const { origin: i2, url: s2, hash: o2 } = g.fromUrl(t);
    return i2 !== window.location.origin || !(!e2 || !this.triggerWillOpenNewWindow(e2)) || !!this.options.ignoreVisit(s2 + o2, { el: e2, event: n2 });
  }
  linkClickHandler(t) {
    const e2 = t.delegateTarget, { href: n2, url: s2, hash: o2 } = g.fromElement(e2);
    if (this.shouldIgnoreVisit(n2, { el: e2, event: t }))
      return;
    if (t.metaKey || t.ctrlKey || t.shiftKey || t.altKey)
      return void this.triggerEvent("openPageInNewTab", t);
    if (0 !== t.button)
      return;
    if (this.triggerEvent("clickLink", t), t.preventDefault(), !s2 || s2 === i())
      return void this.handleLinkToSamePage(s2, o2, t);
    if (this.isSameResolvedUrl(s2, i()))
      return;
    this.scrollToElement = o2 || null;
    const r2 = e2.getAttribute("data-swup-transition") || void 0;
    let a2;
    const l2 = e2.getAttribute("data-swup-history");
    l2 && ["push", "replace"].includes(l2) && (a2 = l2), this.performPageLoad({ url: s2, customTransition: r2, history: a2 });
  }
  handleLinkToSamePage(t, e2, n2) {
    if (e2) {
      if (this.triggerEvent("samePageWithHash", n2), !P(e2))
        return console.warn(`Element for offset not found (#${e2})`);
      o(t + e2);
    } else
      this.triggerEvent("samePage", n2);
  }
  triggerWillOpenNewWindow(t) {
    return !!t.matches('[download], [target="_blank"]');
  }
  popStateHandler(t) {
    var e2, n2;
    if (this.options.skipPopStateHandling(t))
      return;
    if (this.isSameResolvedUrl(i(), this.currentPageUrl))
      return;
    const s2 = null != (e2 = null == (n2 = t.state) ? void 0 : n2.url) ? e2 : location.href;
    if (this.shouldIgnoreVisit(s2, { event: t }))
      return;
    const { url: o2, hash: r2 } = g.fromUrl(s2);
    r2 ? this.scrollToElement = r2 : t.preventDefault(), this.triggerEvent("popState", t), this.options.animateHistoryBrowsing || (document.documentElement.classList.remove("is-animating"), v()), this.performPageLoad({ url: o2, event: t });
  }
  resolveUrl(t) {
    if ("function" != typeof this.options.resolveUrl)
      return console.warn("[swup] options.resolveUrl expects a callback function."), t;
    const e2 = this.options.resolveUrl(t);
    return e2 && "string" == typeof e2 ? e2.startsWith("//") || e2.startsWith("http") ? (console.warn("[swup] options.resolveUrl needs to return a relative url"), t) : e2 : (console.warn("[swup] options.resolveUrl needs to return a url"), t);
  }
  isSameResolvedUrl(t, e2) {
    return this.resolveUrl(t) === this.resolveUrl(e2);
  }
};
export {
  g as Location,
  n as classify,
  v as cleanupAnimationClasses,
  s as createHistoryRecord,
  V as default,
  r as delegateEvent,
  u as escapeCssIdentifier,
  p as fetch,
  i as getCurrentUrl,
  d as getDataFromHtml,
  m as markSwupElements,
  c as nextTick,
  a as query,
  l as queryAll,
  h as toMs,
  o as updateHistoryRecord
};
//# sourceMappingURL=swup.js.map
