'use strict';

var solidJs = require('solid-js');
var web = require('solid-js/web');
var utils = require('@solid-primitives/utils');

// src/index.ts
function observe(el, instance) {
  if (solidJs.DEV && el instanceof HTMLElement && el.style.display === "contents") {
    console.warn(
      `[@solid-primitives/intersection-observer] IntersectionObserver is not able to observe elements with 'display: "contents"' style:`,
      el
    );
  }
  instance.observe(el);
}
function makeIntersectionObserver(elements, onChange, options) {
  if (web.isServer)
    return {
      add: () => void 0,
      remove: () => void 0,
      start: () => void 0,
      reset: () => void 0,
      stop: () => void 0,
      instance: {}
    };
  const instance = new IntersectionObserver(onChange, options);
  const add = (el) => observe(el, instance);
  const remove = (el) => instance.unobserve(el);
  const start = () => elements.forEach(add);
  const reset = () => instance.takeRecords().forEach((el) => remove(el.target));
  start();
  return { add, remove, start, stop: solidJs.onCleanup(() => instance.disconnect()), reset, instance };
}
function createIntersectionObserver(elements, onChange, options) {
  if (web.isServer)
    return;
  const io = new IntersectionObserver(onChange, options);
  solidJs.onCleanup(() => io.disconnect());
  solidJs.createEffect((p) => {
    const list = elements();
    utils.handleDiffArray(
      list,
      p,
      (el) => observe(el, io),
      (el) => io.unobserve(el)
    );
    return list;
  }, []);
}
function createViewportObserver(...a) {
  if (web.isServer) {
    return [() => void 0, { start: () => void 0, stop: () => void 0 }];
  }
  let initial = [];
  let options = {};
  if (Array.isArray(a[0]) || a[0] instanceof Function) {
    if (a[1] instanceof Function) {
      initial = utils.access(a[0]).map((el) => [el, a[1]]);
      options = a[2];
    } else {
      initial = utils.access(a[0]);
      options = a[1];
    }
  } else
    options = a[0];
  const callbacks = /* @__PURE__ */ new WeakMap();
  const onChange = (entries, instance2) => entries.forEach((entry) => {
    const cb = callbacks.get(entry.target)?.(entry, instance2);
    cb instanceof Function && cb(entry, instance2);
  });
  const { add, remove, stop, instance } = makeIntersectionObserver([], onChange, options);
  const addEntry = (el, callback) => {
    add(el);
    callbacks.set(el, callback);
  };
  const removeEntry = (el) => {
    callbacks.delete(el);
    remove(el);
  };
  const start = () => initial.forEach(([el, cb]) => addEntry(el, cb));
  solidJs.onMount(start);
  return [addEntry, { remove: removeEntry, start, stop, instance }];
}
function createVisibilityObserver(options, setter) {
  if (web.isServer) {
    return () => () => false;
  }
  const callbacks = /* @__PURE__ */ new WeakMap();
  const io = new IntersectionObserver((entries, instance) => {
    for (const entry of entries)
      callbacks.get(entry.target)?.(entry, instance);
  }, options);
  solidJs.onCleanup(() => io.disconnect());
  function removeEntry(el) {
    io.unobserve(el);
    callbacks.delete(el);
  }
  function addEntry(el, callback) {
    observe(el, io);
    callbacks.set(el, callback);
  }
  const getCallback = setter ? (get, set) => {
    const setterRef = utils.access(setter);
    return (entry) => set(setterRef(entry, { visible: solidJs.untrack(get) }));
  } : (_, set) => (entry) => set(entry.isIntersecting);
  return (element) => {
    const [isVisible, setVisible] = solidJs.createSignal(options?.initialValue ?? false);
    const callback = getCallback(isVisible, setVisible);
    let prevEl;
    if (!(element instanceof Element)) {
      solidJs.createEffect(() => {
        const el = element();
        if (el === prevEl)
          return;
        if (prevEl)
          removeEntry(prevEl);
        if (el)
          addEntry(el, callback);
        prevEl = el;
      });
    } else
      addEntry(element, callback);
    solidJs.onCleanup(() => prevEl && removeEntry(prevEl));
    return isVisible;
  };
}
exports.Occurrence = /* @__PURE__ */ ((Occurrence2) => {
  Occurrence2["Entering"] = "Entering";
  Occurrence2["Leaving"] = "Leaving";
  Occurrence2["Inside"] = "Inside";
  Occurrence2["Outside"] = "Outside";
  return Occurrence2;
})(exports.Occurrence || {});
function getOccurrence(isIntersecting, prevIsIntersecting) {
  if (web.isServer) {
    return "Outside" /* Outside */;
  }
  return isIntersecting ? prevIsIntersecting ? "Inside" /* Inside */ : "Entering" /* Entering */ : prevIsIntersecting === true ? "Leaving" /* Leaving */ : "Outside" /* Outside */;
}
function withOccurrence(setter) {
  if (web.isServer) {
    return () => () => false;
  }
  return () => {
    let prevIntersecting;
    const cb = utils.access(setter);
    return (entry, ctx) => {
      const { isIntersecting } = entry;
      const occurrence = getOccurrence(isIntersecting, prevIntersecting);
      prevIntersecting = isIntersecting;
      return cb(entry, { ...ctx, occurrence });
    };
  };
}
exports.DirectionX = /* @__PURE__ */ ((DirectionX2) => {
  DirectionX2["Left"] = "Left";
  DirectionX2["Right"] = "Right";
  DirectionX2["None"] = "None";
  return DirectionX2;
})(exports.DirectionX || {});
exports.DirectionY = /* @__PURE__ */ ((DirectionY2) => {
  DirectionY2["Top"] = "Top";
  DirectionY2["Bottom"] = "Bottom";
  DirectionY2["None"] = "None";
  return DirectionY2;
})(exports.DirectionY || {});
function getDirection(rect, prevRect, intersecting) {
  if (web.isServer) {
    return {
      directionX: "None" /* None */,
      directionY: "None" /* None */
    };
  }
  let directionX = "None" /* None */;
  let directionY = "None" /* None */;
  if (!prevRect)
    return { directionX, directionY };
  if (rect.top < prevRect.top)
    directionY = intersecting ? "Bottom" /* Bottom */ : "Top" /* Top */;
  else if (rect.top > prevRect.top)
    directionY = intersecting ? "Top" /* Top */ : "Bottom" /* Bottom */;
  if (rect.left > prevRect.left)
    directionX = intersecting ? "Left" /* Left */ : "Right" /* Right */;
  else if (rect.left < prevRect.left)
    directionX = intersecting ? "Right" /* Right */ : "Left" /* Left */;
  return { directionX, directionY };
}
function withDirection(callback) {
  if (web.isServer) {
    return () => () => false;
  }
  return () => {
    let prevBounds;
    const cb = utils.access(callback);
    return (entry, ctx) => {
      const { boundingClientRect } = entry;
      const direction = getDirection(boundingClientRect, prevBounds, entry.isIntersecting);
      prevBounds = boundingClientRect;
      return cb(entry, { ...ctx, ...direction });
    };
  };
}

exports.createIntersectionObserver = createIntersectionObserver;
exports.createViewportObserver = createViewportObserver;
exports.createVisibilityObserver = createVisibilityObserver;
exports.getDirection = getDirection;
exports.getOccurrence = getOccurrence;
exports.makeIntersectionObserver = makeIntersectionObserver;
exports.withDirection = withDirection;
exports.withOccurrence = withOccurrence;
